---
layout: single
title: "Java Internals: A Legacy Reforged"
classes: wide
toc: true
---

> “I can only show you the door. You’re the one that has to walk through it.” - Morpheus, The Matrix.

# Fundamentals
## Java Virtual Machine (JVM)
**Adaptive compiler**
- **Standard Interpreter at Launch**
    - Initially, the application runs using a basic interpreter.
    - This allows quick startup times since no compilation is performed upfront.
- **Hot Spot Detection**
    - The VM monitors runtime behavior to identify frequently executed portions of the code, known as _hot spots_.
    - These hot spots are analyzed for potential optimizations.
- **Selective Compilation**
    - Only performance-critical code is compiled into machine code, while seldom-used code remains interpreted.
    - This balances optimization effort with runtime performance.
- **Optimization Techniques**
    - **Inlining**: Frequently invoked methods are embedded directly into the caller, reducing method call overhead.
    - **Loop Unrolling**: Iterative loops are expanded to reduce the number of iterations and branch instructions.
    - **Speculative Optimizations**: Assumptions about code behavior (e.g., object types) are made to optimize performance. These optimizations can be reverted if assumptions prove incorrect (deoptimization).

**Rapid Memory Allocation**

The HotSpot VM allocates memory for objects efficiently using *Thread-Local Allocation Buffers (TLABs)*:
- Each thread is provided a small chunk of memory to minimize contention with other threads.
- Allocation from TLABs is extremely fast (essentially a pointer increment).

**[Garbage Collection](https://docs.oracle.com/en/java/javase/23/gctuning/garbage-collector-implementation.html#GUID-23844E39-7499-400C-A579-032B68E53073)**
- **Serial GC**
    - Designed for single-threaded environments.
    - Performs stop-the-world garbage collection.
- **Parallel GC (Throughput Collector)**
    - Utilizes multiple threads for both minor and major garbage collections.
    - Suitable for applications requiring high throughput.
- **Concurrent Mark-Sweep (CMS) Collector**
    - Focuses on reducing application pause times by performing most of its work concurrently with the application threads.
- **G1 GC (Garbage-First)**
    - Divides the heap into regions and prioritizes garbage collection in regions with the most garbage.
    - Ideal for applications with large heaps and low-latency requirements.
- **ZGC (Z Garbage Collector)** and **Shenandoah**
    - Advanced low-latency garbage collectors.
    - Perform concurrent compaction, reducing pause times to a few milliseconds even for large heaps.

**[Thread synchronization](https://www.javatpoint.com/synchronization-in-java)**
- Efficient Locking Mechanisms
    - Biased Locking: Locks are biased toward a single thread to avoid overhead when contention is low.
    - Lightweight Locking: CAS-based (Compare-And-Swap) locks are used for uncontended locks to reduce synchronization costs.
    - Heavyweight Locks: Used when threads compete heavily for a resource.
- Scalable Thread Management
    - The HotSpot VM is designed to handle a large number of threads efficiently, scaling well on shared-memory multiprocessor servers.
- Thread Coordination
    - Threads cooperate during garbage collection and JIT compilation, ensuring minimal disruption to application execution.

**Class Loaders**

JVM uses class loaders as there is no runtime linker.
- Bootstrap ClassLoader
	- The **root** of the ClassLoader hierarchy.
	- It is part of the **JVM implementation** and written in native code (not Java).
	- Does not extend the `java.lang.ClassLoader` class, but acts as the **superclass** for other ClassLoaders.
	- Loads the **core Java classes** required for basic functioning, such as classes from the `java.lang`, `java.util`, `java.io`, `java.net`, and `java.sql` packages.
	- **Classpath** for the Bootstrap ClassLoader is typically hardcoded and points to locations like: `<JAVA_HOME>/lib`, `rt.jar`, `charsets.jar`, or similar core libraries.
	- Cannot be directly accessed or modified by developers.
- Extension/Platform ClassLoader
	- **Child ClassLoader** of the Bootstrap ClassLoader.
	- Used for loading Java extensions (optional packages).
	- Loads classes from the `$JAVA_HOME/jre/lib/ext` directory or any directories specified in the `java.ext.dirs` system property.
	- Handles classes such as cryptographic providers, additional API libraries, or any external libraries placed in the `ext` directory.
	- If a class is not found in the `ext` directory, the Extension ClassLoader delegates the request to the Bootstrap ClassLoader.
- System/Application ClassLoader
	- The **child** of the Extension ClassLoader.
	- Responsible for loading application-specific classes and resources.
	- Loads classes specified by the **`classpath`** environment variable or passed via the `-cp` or `-classpath` JVM argument.
    - Typically includes directories, JAR files, or compiled `.class` files from the project workspace.
    - Points to the **current working directory** (`.`).
	- Developers can customize it using tools like Maven or Gradle for dependency management.
	- It is an instance of `java.lang.ClassLoader`.
	- Most user-defined classes and third-party libraries are loaded using the System ClassLoader.
- Custom ClassLoaders
	- Create custom ClassLoaders by extending the `java.lang.ClassLoader` class for advanced use cases like:
		- Loading classes from custom locations (e.g., network, encrypted files).
		- Implementing dynamic module systems or plugin architectures.
- Readmore:
	- [Class Loaders in Java](https://www.baeldung.com/java-classloaders)
	- [How does the Java ClassLoader System really work? (with pictures)](https://medium.com/@wakefulinsomnia/how-does-java-classloader-system-work-82eaf378f73b)
	- [ClassLoader in Java](https://www.javatpoint.com/classloader-in-java)

**[Java Bytecode](https://en.wikipedia.org/wiki/Java_bytecode)**
- Java bytecode allows "write once, run anywhere" by abstracting machine-specific details to the underlying hardware.
- The bytecode format is designed to be *compact*, making it suitable for network transmission.
- Optimized for quick interpretation or Just-In-Time (JIT) compilation.
- Bytecode runs inside the JVM sandbox, offering better security and preventing direct access to underlying hardware or OS.
- Java provides the `javap` tool to inspect compiled `.class` files and view their bytecode: `javap -c Test.class`.
- List of [Java bytecode instructions](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions).
- Advanced Bytecode Inspection Tools
	- [ASM Framework](https://asm.ow2.io/): Analyze or modify bytecode programmatically.
	- [Byte Buddy](https://bytebuddy.net/): Simplifies creating or modifying bytecode at runtime.
	- [Javassist](http://www.javassist.org/): High-level API for editing bytecode dynamically.

**Readmore JVM**
- [Java Virtual Machine Technology Overview](https://docs.oracle.com/en/java/javase/23/vm/java-virtual-machine-technology-overview.html)
- [JVM (Java Virtual Machine) Architecture](https://www.javatpoint.com/jvm-java-virtual-machine)

---

## Application Input
**Dependence on Frameworks**
- [Apache Struts](https://struts.apache.org/getting-started/)
    - Uses `ActionForm` to model user data and process input.
    - Struts v1.x: `struts-config.xml` (action mappings to `*.do`)
    - Struts v2.x: `struts.xml` (action mappings to `*.action`)
    - Look for classes extending `Action`.
    - Action mappings and form beans configured in XML files.
    - Dynamic method invocation for flexible routing.
    - Interceptor stacks for pre/post-processing.
    - Debugging Struts : [debugging-struts](https://struts.apache.org/getting-started/debugging-struts)
- [Spring MVC](https://docs.spring.io/spring-framework/reference/)
	- Modular architecture for enterprise Java applications.
	- Readmore: [Spring MVC Tutorial](https://www.javatpoint.com/spring-mvc-tutorial) and [Spring – MVC Framework](https://www.geeksforgeeks.org/spring-mvc-framework/)
- [Hibernate](https://hibernate.org/orm/)
	- Hibernate reduces redundancy via JDBC API.
	- Hibernate improves productivity and maintainability.
	- Hibernate supports Persistence APIs.
	- [Hibernate's ORM](https://en.wikipedia.org/wiki/Hibernate_(framework)) allows communication between the application and [any database](https://github.com/hibernate/hibernate-orm?tab=readme-ov-file#running-database-specific-tests-from-the-ide-using-profiles).
	- Readmore: [Hibernate Tutorial](https://www.geeksforgeeks.org/hibernate-tutorial/) and [Hibernate](https://www.javatpoint.com/hibernate-tutorial)

**Low-level Input Classes**

Low-level input classes provide **direct access** to HTTP request data.
- `ServletRequest`
	- The **base interface** for all requests in the Servlet API.
	- Provides generic functionality applicable to all types of requests (HTTP or non-HTTP).
	- [Key Methods](https://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/javax/servlet/ServletRequest.html)
- `HttpServletRequest`
	- **Specialized subclass** of `ServletRequest` for HTTP-specific functionality.
	- Provides **fine-grained control** over HTTP request data, including headers, query parameters, and cookies.
	- Extends functionality to support **HTTP-specific operations**.
	- [Key Methods](https://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/javax/servlet/http/HttpServletRequest.html)

**Web Container**
- A *Java-based server environment* responsible for running web applications and managing their lifecycle.
- Manages the **lifecycle of servlets** from initialization to destruction.
- Automatically handles resource allocation, threading, and cleanup.
- Typically part of a larger **Java EE application server** (e.g., GlassFish, WildFly).
- Can function independently as a lightweight **standalone web server**.
- Supports *Web Application Resource (WAR)* files.
	- Servlets
	- JSP files
	- Static resources (HTML, CSS, JS)
	- Configuration files like `web.xml`
- Implements Java Specification Requests (JSR):
    - [Java Servlets](https://jcp.org/ja/jsr/detail?id=369): Core technology for handling HTTP requests and responses.
    - [JavaServer Pages (JSP)](https://jcp.org/ja/jsr/detail?id=245): Allows embedding Java code within HTML for dynamic content.
    - [JavaServer Faces (JSF)](https://jcp.org/en/jsr/detail?id=372): A framework for building component-based UIs for web applications.
	    - Components: Facelets, Filters, Web.xml
		- Implementations: Mojarra, MyFaces
- Examples: *Apache Tomcat* and *Jetty*

**Application Server**
- Encapsulates a web container and supports *Enterprise Application Archives (EAR)*. An EAR file can include:
	- *WAR files* for web components.
	- *JAR files* for business logic and backend services.
- Adds capabilities for handling **business logic**, **transaction management**, and **data persistence**.
- Provides a full J2EE specification with APIs like:
    - [Enterprise Java Beans (EJB)](https://jcp.org/aboutJava/communityprocess/final/jsr220/index.html)
	    - Declarative transaction management.
	    - [Remote method invocation](https://www.geeksforgeeks.org/enterprise-java-beans-ejb/).
	    - Stateful and stateless session beans.
    - [Java Persistence API (JPA)](https://www.oracle.com/java/technologies/persistence-jsp.html)
	    - [Standardized ORM](https://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html) (Object-Relational Mapping) for managing relational data in Java.
		- Simplifies [database interactions](https://medium.com/@lktsdvd/what-is-java-persistence-api-jpa-2763d0c1ee73) using annotations like `@Entity`, `@Table`, and `@Column`.
    - [Java Transaction API (JTA)](https://www.oracle.com/java/technologies/jta.html)
	    - Provides a standard interface for managing distributed transactions.
		- Supports **two-phase commit** and integration with multiple data sources.
	- [Java Message Service (JMS)](https://jcp.org/en/jsr/detail?id=343)
		- Enables asynchronous communication using message queues or topics.
		- Useful for [decoupled systems](https://www.javatpoint.com/jms-tutorial) and [event-driven architectures](https://medium.com/@gaganjain9319/jms-java-message-service-detailed-explanation-50bc5ba6e3ef).
	- [JavaMail API](https://www.javatpoint.com/java-mail-api-tutorial)
		- Simplifies sending and receiving email.
- Dependency Injection via `@Inject` annotation.
	- Automatically provides the required implementation of a dependency.
	- Part of *[CDI (Contexts and Dependency Injection)](https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html)* in Java EE.
- Example: Apache GlassFish, WildFly, IBM WebSphere and Oracle WebLogic

---
## Serialization
**Key Features**
- Serialization in Java is the process of converting an object into a byte stream, enabling the object to be easily saved to a file, transmitted over a network, or otherwise persisted.

**Magic Methods**
- `readObject()`: Used during deserialization to read and reconstruct the object. Custom implementations can validate or modify the deserialized data.
```java
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
    ois.defaultReadObject();
    // Additional validation or initialization
}
```

- `readResolve()` : Called after readObject(). Allows returning a replacement object, potentially preventing multiple deserialized instances.
```java
private Object readResolve() throws ObjectStreamException {
    return Singleton.INSTANCE;
}
```

- `validateObject()`: Called after readResolve(), but only if the serialized class is implementing the ObjectInputValidation interface.
```java
public void validateObject() throws InvalidObjectException {
    if (someField == null) {
        throw new InvalidObjectException("Invalid object state");
    }
}
```

- `readObjectNoData()`: Called when the serialized object’s superclass differs from the class being deserialized.
- Object.finalize() : Rarely relevant during serialization/deserialization, but it might be triggered if garbage collection interacts with the object lifecycle.

**Interfaces for Serialization**
- `java.io.Serializable`: Marks a class as serializable. It does not contain any methods.
- `FileOutputStream` and `ObjectOutputStream`
```java
FileOutputStream fos = new FileOutputStream("object.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(myObject);
oos.close();
```

**Contents of Serialized Data**
Stores no code, but includes:
- Variable types, names, and values.
- Class names.

**Multi-object Streams**
- Serialized streams can contain multiple objects sequentially, with no global headers.
- Each deserialized object must be read in the same order.
```java
oos.writeObject(obj1);
oos.writeObject(obj2);
```

**Security Notes**
- Exposes private fields unless marked as `transient`.
- Insecure implementations of `readObject()` or `validateObject()` can allow invalid or malicious states.
- Restrict classes that can be deserialized using [JEP 290](https://docs.oracle.com/en/java/javase/11/core/serialization-filtering1.html#GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A)
- Use JSON or XML libraries for serialization (e.g., Jackson, Gson).

**Readmore**: 
- [Java Serialization Specification](https://docs.oracle.com/en/java/javase/22/docs/specs/serialization/index.html)
- [Serialization and Deserialization in Java with Example](https://www.geeksforgeeks.org/serialization-in-java/)
- [Java - Serialization](https://www.tutorialspoint.com/java/java_serialization.htm)
- [Introduction to Java Serialization](https://www.baeldung.com/java-serialization)
- [Java Object Serialization](https://docs.oracle.com/javase/8/docs/technotes/guides/serialization/)
- [Serialization and Deserialization in Java](https://www.javatpoint.com/serialization-in-java)

---
## Deserialization
**Goal**
- Achieve RCE, SSRF, authentication bypass, etc.

**Requirements**
1. **Entry Point**:
    - Any Java object deserialization influenced by *user-controlled input* is probably vulnerable.
    - Look for `ObjectInputStream.readObject()`, `Externalizable.readExternal()`, or custom methods.
    - Search for serialized Java objects (e.g., `0xaced0005` or `rO0` in Base64, GZIP: `H4sIA`, Content-type: `application/x-java-serialized-object`).
2. **Gadget Chain**:
    - A gadget is a class with methods that an attacker leverages to execute arbitrary code or perform unintended actions during deserialization.
    - Example gadgets: Collections, annotations, or proxy objects with custom `readObject()` or `invoke()` methods.
    - Readmore: [Finding gadgets like it's 2022](https://www.synacktiv.com/publications/finding-gadgets-like-its-2022.html)

**Popular Exploitation Libraries**
- Ysoserial
	- A tool that generates payloads for exploiting Java deserialization vulnerabilities.
	- Supports multiple gadgets like: Apache Commons Collections, Groovy and Spring Beans.
	- `java -jar ysoserial.jar CommonsCollections5 "calc" | base64`

**Internal Mechanics**
- Deserialization is handled by `ObjectInputStream.readObject()`.
- Reflection via `ObjectStreamClass`.
	- Determines the class to instantiate.
	- Uses reflection to allocate memory and reconstruct fields.
- Custom Logic via Magic Methods:
	- `readObject()`: Custom logic for reading serialized fields.
	- `readResolve()`: Returns the final object, potentially replacing the deserialized instance.
	- `validateObject()`: Validates object state if implementing `ObjectInputValidation`.

**Deserialization Pitfalls**
- Transient and static fields are not serialized.
- Constructors and non-magic methods are not called.
- Only magic methods trigger deserialization logic.
- Exploitable deserialization relies on classpath-linked libraries for gadget chains.

**Trampolines Gadgets**
- Gadgets like `HashSet` can invoke arbitrary methods (`hashCode()` on set elements).
	- The `readObject()` of `HashSet` deserializes elements. 
	- It invokes `hashCode()` on each deserialized element to maintain hash integrity.
	- By inserting a malicious object with an overridden `hashCode()` method, attackers can execute arbitrary code.
```java
public class MaliciousHashCode {
    @Override
    public int hashCode() {
        // Malicious payload triggered during HashSet deserialization
        Runtime.getRuntime().exec("calc");
        return 42;
    }
}
```

Readmore :
- [What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability.](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [Java deserialization vulnerabilities - The forgotten bug class](https://www.youtube.com/watch?v=9Bw1urhk8zw)

---
## Expression Language (EL)
- Used in JSP/JSF to link presentation layers (UI) with application logic.

**EL Injection**
- Occurs when untrusted input is evaluated by an EL parser.
- Types of expressions:
    - Value: `#{}` as immediate evaluation
    - Method: `${}` as deferred evaluation
- Composite expressions are allowed but mixing of # and $ is prohibited

**Capabilities**
- Access properties:
```java
${sessionScope.cart.numberOfItems}
${param['productId']}
${header["host"]}
```
- Perform operations:
```java
${18 mod 3}
${'crit' gt 'crot'}
${(5*5) ne 25}
```
- You can not just reference any variable in the Java application via EL, only: Lambda parameters, Literals, Managed beans, Implicit objects and Variables defined in the xhtml

Readmore: [Expression Language (EL) in JSP](https://www.javatpoint.com/EL-expression-in-jspv)

---
## Debugging
**Java Code Modification**
- **Burp Suite Infiltrator**: Patches bytecode to add hooks for unsafe API calls.

**Java Debuggers**
- Use Eclipse IDE with `jd-eclipse` for decompiling closed-source code.
- Use [JD-GUI](https://java-decompiler.github.io/) to decompile java applications.

**JDWP**
- Debugger Wire Protocol for remote debugging.
- Security Concerns:
    - No authentication or encryption.
    - Detectable via `JDWP-Handshake`.
- Finding hosts exposing JDWP
	- Locally check in the process list for strings such as:
		- `-Xdebug`
		- `-Xrunjdwp`
		-  `-agentlib:jdwp`
		- `transport=dt_socket`
		- the address option indicates the listening port number
	- Remotely
		- Send "JDWP-Handshake" and see if the host responds with the same string. If no reply is got it means the remote service is JDWP.
		- Use nmap –sV option: `$ nmap -sV -P0 -n -p`
		- JDWP has *no default listening port*, you can search inside code repositories (github, gitlab, etc.)

---
